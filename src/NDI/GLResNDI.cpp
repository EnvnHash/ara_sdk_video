#ifndef __ANDROID__

#include <locale>
#include <codecvt>
#include <sstream>
#include "GLResNDI.h"
#include <GeoPrimitives/Quad.h>
#include <Utils/Texture.h>

using namespace std;
using namespace glm;
namespace fs = std::filesystem;

namespace ara::av::NDI
{

GLResNDI::GLResNDI() : m_typoColor(glm::vec4{1.f, 1.f, 1.f, 1.f}), m_typoFontSize(45)
{}

void GLResNDI::init(uint32_t scrWidth, uint32_t scrHeight, fs::path dataPath, GLBase* glbase) {
    if (!m_inited)
    {
        m_typo = make_unique<TypoGlyphMap>(scrWidth, scrHeight);
        m_typo->loadFont((dataPath / "Fonts" / "open-sans" / "OpenSans-Light.ttf").string().c_str(), &m_shCol);

        m_stdQuad = make_unique<Quad>(QuadInitParams{ .color = vec4{0.f, 0.f, 0.f, 1.f} });
        m_flipQuad = make_unique<Quad>(QuadInitParams{
            .color = vec4{1.f, 1.f, 1.f, 1.f},
            .flipHori = true
        });

        m_renderShdr = initRenderShdr();
        m_stdCol = m_shCol.getStdCol();
        m_frameTex = make_unique<Texture>(glbase);

        m_inited = true;
    }
}

void GLResNDI::destroy() {
    if (m_inited) {
        m_typo.release();
        m_inited = false;
    }
}

Shaders* GLResNDI::initRenderShdr() {
    string vert = m_shCol.getShaderHeader();
    vert += STRINGIFY(
        layout(location = 0) in vec4 position; \n
        layout(location = 2) in vec2 texCoord;
        uniform sampler2D tex;
        out vec2 tex_coord; \n
        void main() { \n
            ivec2 tsize = textureSize(tex, 0);
            tex_coord = vec2(texCoord.x * tsize.x, texCoord.y * tsize.y); \n
            gl_Position = position; \n
        });

    string frag = m_shCol.getShaderHeader();
    frag += STRINGIFY(
        layout(location = 0) out vec4 fragColor; \n
        in vec2 tex_coord; \n
        uniform sampler2D tex;
        uniform float op=1;
        void main()\n
        { \n
            ivec2 a = ivec2(tex_coord);
            vec3 ycbcr;
            vec4 texCol = texelFetch(tex, a, 0);

            ycbcr.x = texCol.g;
            ycbcr.y = ((a.x & 1) == 0 ? texCol.r : texelFetch(tex, ivec2(a.x - 1, a.y), 0).r) - 0.5;
            ycbcr.z = ((a.x & 1) == 0 ? texelFetch(tex, ivec2(a.x + 1, a.y), 0).r : texCol.r) - 0.5;

            fragColor = vec4(ycbcr.x + (1.4065 * (ycbcr.z)),
                             ycbcr.x - (0.3455 * (ycbcr.y)) - (0.7169 * (ycbcr.z)),
                             ycbcr.x + (1.7790 * (ycbcr.y)), texCol.a*op);
        }
    );

    return m_shCol.add("NDIRender", vert, frag);
}

void GLResNDI::drawDisplayName() {
    if (m_inited) {
        // calculate the relative size of the resulting typo texture generated by the TypoGlyphMap
        vec2 typoTexSize = m_typo->getTextWidth(m_dispName.c_str(), m_typoFontSize);

        // put the monitor name to the top of the screen with a slight border
        float yOffs = 1.f - typoTexSize.y - 0.05f;

        // black background
        // note: TypoGlyphMap aligns to base line, but we need to have the centers of the background
        // rect and the typo texture match
        mat4 backGr = glm::translate(vec3(0.f, yOffs + typoTexSize.y * 0.3f, 0.f))
            * glm::scale(vec3(typoTexSize.x * 0.5f, typoTexSize.y * 0.5f, 1.f));

        m_stdCol->begin();
        m_stdCol->setUniformMatrix4fv("m_pvm", &backGr[0][0]);
        m_stdQuad->draw();

        // m_typo->setColor(1.f, 1.f, 1.f, 1.f);
        // create a texture with the name of the monitor, (note if the name doesn't change this is done only once)
        m_typo->print(typoTexSize.x * -0.5f, yOffs, m_dispName, m_typoFontSize, &m_typoColor[0]);
    }
}

}

#endif